{"mappings":"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","sources":["node_modules/three/examples/jsm/loaders/LDrawLoader.js","src/materials/LambertPathTracingMaterial.js","src/core/MaterialReducer.js","node_modules/three/examples/jsm/libs/stats.module.js","example/lambert.js","src/viewers/PathTracingViewer.js","node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingConstructionStep = original.startingConstructionStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_AS_IS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_AS_IS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingConstructionStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingConstructionStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingConstructionStep: startingConstructionStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingConstructionStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial.userData.conditionalEdgeMaterial );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n//\n\nclass LDrawLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// Initializes the materials library with default materials\n\t\tthis.setMaterials( [] );\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t}\n\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setMaterials( materials );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeConstructionSteps( group );\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, onLoad ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.computeConstructionSteps( group );\n\t\t\t\tonLoad( group );\n\n\t\t\t} );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw an error if this is final opportunity to set the material\n\t\t\t\t\tthrow new Error( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = material.userData.edgeMaterial;\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = material.userData.conditionalEdgeMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\tgetMainEdgeMaterial() {\n\n\t\tconst mainMat = this.getMainMaterial();\n\t\treturn mainMat && mainMat.userData ? mainMat.userData.edgeMaterial : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet color = 0xFF00FF;\n\t\tlet edgeColor = 0xFF00FF;\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\tcase 'CODE':\n\n\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\tcolor = lineParser.getToken();\n\t\t\t\t\tif ( color.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\tcolor = '#' + color.substring( 2 );\n\n\t\t\t\t\t} else if ( ! color.startsWith( '#' ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\tedgeMaterial = edgeMaterial.userData.edgeMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\tluminance = parseInt( lineParser.getToken() );\n\n\t\t\t\t\tif ( isNaN( luminance ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tluminance = Math.max( 0, Math.min( 1, luminance / 255 ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CHROME':\n\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RUBBER':\n\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'METAL':\n\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t// Not implemented\n\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\t\tmaterial.color.convertSRGBToLinear();\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.set( material.color ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: edgeColor,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\t\t\tedgeMaterial.color.convertSRGBToLinear();\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: edgeColor,\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.color.convertSRGBToLinear();\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tmaterial.userData.edgeMaterial = edgeMaterial;\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t}\n\n\tcomputeConstructionSteps( model ) {\n\n\t\t// Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingConstructionStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.constructionStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numConstructionSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import { ShaderMaterial, Matrix4, Color } from 'three';\nimport {\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs, pathTracingHelpers } from '../shader/shaderStructs.js';\nimport { MaterialStructArrayUniform } from '../uniforms/MaterialStructArrayUniform.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\n\nexport class LambertPathTracingMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\t\t\t\tBOUNCES: 3,\n\t\t\t\tMATERIAL_LENGTH: 0,\n\t\t\t\tUSE_ENVMAP: 1,\n\t\t\t\tGRADIENT_BG: 0,\n\t\t\t\tDISPLAY_FLOOR: 1,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialStructArrayUniform() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tenvironmentBlur: { value: 0.2 },\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\n\t\t\t\tenvironmentMap: { value: null },\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t\tgradientTop: { value: new Color( 0xbfd8ff ) },\n\t\t\t\tgradientBottom: { value: new Color( 0xffffff ) },\n\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\n\n\t\t\t\tfloorHeight: { value: 0.0 },\n\t\t\t\tfloorColor: { value: new Color( 0x080808 ) },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n                varying vec2 vUv;\n                void main() {\n\n                    vec4 mvPosition = vec4( position, 1.0 );\n                    mvPosition = modelViewMatrix * mvPosition;\n                    gl_Position = projectionMatrix * mvPosition;\n\n                    vUv = uv;\n\n                }\n\n            `,\n\n\t\t\tfragmentShader: /* glsl */`\n                #define RAY_OFFSET 1e-5\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n                precision highp isampler2D;\n                precision highp usampler2D;\n                precision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n                #include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n                ${ shaderStructs }\n                ${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\t\t\t\t${ pathTracingHelpers }\n\n\t\t\t\t#if USE_ENVMAP\n\n\t\t\t\tuniform float environmentBlur;\n                uniform sampler2D environmentMap;\n\n\t\t\t\t#else\n\n                uniform vec3 gradientTop;\n                uniform vec3 gradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n                uniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\tuniform vec3 floorColor;\n\t\t\t\tuniform float floorHeight;\n\n\t\t\t\t#endif\n\n                uniform mat4 cameraWorldMatrix;\n                uniform mat4 invProjectionMatrix;\n                uniform sampler2D normalAttribute;\n                uniform sampler2D tangentAttribute;\n                uniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n                uniform BVH bvh;\n                uniform float environmentIntensity;\n                uniform int seed;\n                uniform float opacity;\n\t\t\t\tuniform Material materials[ MATERIAL_LENGTH ];\n\t\t\t\tuniform sampler2DArray textures;\n                varying vec2 vUv;\n\n                void main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n                    // get [-1, 1] normalized device coordinates\n                    vec2 ndc = 2.0 * vUv - vec2( 1.0 );\n                    vec3 rayOrigin, rayDirection;\n                    ndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n                    // Lambertian render\n                    gl_FragColor = vec4( 0.0 );\n\n                    vec3 throughputColor = vec3( 1.0 );\n\n                    // hit results\n                    uvec4 faceIndices = uvec4( 0u );\n                    vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n                    vec3 barycoord = vec3( 0.0 );\n                    float side = 1.0;\n                    float dist = 0.0;\n\t\t\t\t\tint i;\n                    for ( i = 0; i < BOUNCES; i ++ ) {\n\n                        if ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\t\t\t\t// display a radial gradient floor\n\t\t\t\t\t\t\tfloat distToFloor = ( floorHeight - rayOrigin.y ) / rayDirection.y;\n\t\t\t\t\t\t\tvec3 floorNormal = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\t\t\t\tvec3 floorHitPoint = rayOrigin + rayDirection * distToFloor + floorNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tfloat centerDist = length( floorHitPoint.xz );\n\t\t\t\t\t\t\tfloat alpha = pow( saturate( 1.25 - centerDist ), 2.0 );\n\t\t\t\t\t\t\tif ( distToFloor > dist && dot( floorNormal, rayDirection ) < 0.0 && alpha > rand() ) {\n\n\t\t\t\t\t\t\t\trayOrigin = floorHitPoint;\n\t\t\t\t\t\t\t\trayDirection = getHemisphereSample( floorNormal, rand2() );\n\t\t\t\t\t\t\t\tthroughputColor *= floorColor / PI;\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\n\t\t\t\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\t\t\t\tgl_FragColor = vec4( mix( bgGradientBottom, bgGradientTop, value ), 1.0 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if USE_ENVMAP\n\n                            vec3 skyColor = textureCubeUV( environmentMap, rayDirection, environmentBlur ).rgb;\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\t\t\t\t\t\t\tvec3 skyColor = mix( gradientBottom, gradientTop, value );\n\n\t\t\t\t\t\t\t#endif\n\n                            gl_FragColor += vec4( skyColor * throughputColor * environmentIntensity, 1.0 );\n\n                            break;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = materials[ materialIndex ];\n\n\t\t\t\t\t\tif ( material.opacity < rand() ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\trayOrigin += rayDirection * dist - faceNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tthroughputColor *= mix( vec3( 1.0 ), material.color, 0.5 * material.opacity );\n\n\t\t\t\t\t\t\ti --;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n                        // fetch the interpolated smooth normal\n                        vec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl_FragColor.rgb += throughputColor * emission * max( side, 0.0 );\n\n\t\t\t\t\t\t// 1 / PI attenuation for physically correct lambert model\n                        // https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\n                        throughputColor *= 1.0 / PI;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tthroughputColor *= material.color;\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tthroughputColor *= texture2D( textures, vec3( uv, material.map ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n                        // adjust the hit point by the surface normal by a factor of some offset and the\n                        // maximum component-wise value of the current point to accommodate floating point\n                        // error as values increase.\n                        vec3 point = rayOrigin + rayDirection * dist;\n                        vec3 absPoint = abs( point );\n                        float maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n                        rayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * RAY_OFFSET;\n                        rayDirection = getHemisphereSample( normal, rand2() );\n\n\t\t\t\t\t\t// if the surface normal is skewed such that the outgoing vector can wind up underneath\n\t\t\t\t\t\t// the triangle surface then just consider it absorbed.\n\t\t\t\t\t\tif ( dot( rayDirection, faceNormal ) < 0.0 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\n                    }\n\n\t\t\t\t\t// gl_FragColor.rgb = mix( gl_FragColor.rgb / 2.0, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n\t\t\t\t\t// gl_FragColor.rgb = mix( textureCubeUV( environmentMap, rayDirection, 0.0 ).rgb, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n                    gl_FragColor.a = opacity;\n\n                }\n\n            `\n\n\t\t} );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","var Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport default Stats;\n","import { ACESFilmicToneMapping, NoToneMapping, Box3, LoadingManager, EquirectangularReflectionMapping, PMREMGenerator, Sphere, Color, DoubleSide } from 'three';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { LDrawLoader } from 'three/examples/jsm/loaders/LDrawLoader.js';\nimport { LDrawUtils } from 'three/examples/jsm/utils/LDrawUtils.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { PathTracingViewer } from '../src/viewers/PathTracingViewer.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\n\nconst creditEl = document.getElementById( 'credits' );\nconst loadingEl = document.getElementById( 'loading' );\nconst samplesEl = document.getElementById( 'samples' );\n\nconst viewer = new PathTracingViewer();\nviewer.init();\nviewer.domElement.style.width = '100%';\nviewer.domElement.style.height = '100%';\ndocument.body.appendChild( viewer.domElement );\n\nconst envMaps = {\n\t'Royal Esplanade': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr',\n\t'Moonless Golf': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr',\n\t'Overpass': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr',\n\t'Venice Sunset': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr',\n};\n\nconst models = window.MODEL_LIST || {\n\t'M2020 Rover': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/nasa-m2020/Perseverance.glb',\n\t\tcredit: 'Model credit NASA / JPL-Caltech',\n\t},\n\t'Neko Stop Diorama': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/neko-stop-diorama/scene.gltf',\n\t\tcredit: 'Model by \"Art by Kidd\" on Sketchfab.',\n\t\trotation: [ 0, 1.15 * Math.PI / 4, 0 ],\n\t\tremoveEmission: true,\n\t},\n\t'Japanese Temple': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/japanese-temple/scene.gltf',\n\t\tcredit: 'Japanese Temple Model by \"Aditya Graphical\" on Sketchfab.',\n\t},\n\t'Statue': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Le_Transi_De_Rene_De_Chalon.glb',\n\t\tcredit: 'Model courtesy of threedscans.com.',\n\t},\n\t'Crab Sculpture': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Elbow_Crab.glb',\n\t\trotation: [ 3.1 * Math.PI / 4, Math.PI, 0 ],\n\t\tcredit: 'Model courtesy of threedscans.com.',\n\t},\n\t'Stylized Carriage': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/wooden-stylised-carriage/scene.gltf',\n\t\tcredit: 'Model by \"LamedeFeu\" on Sketchfab.',\n\t},\n\n};\n\nconst params = {\n\n\tacesToneMapping: true,\n\tresolutionScale: 0.75 / window.devicePixelRatio,\n\ttilesX: 2,\n\ttilesY: 2,\n\tsamplesPerFrame: 1,\n\n\tmodel: Object.keys( models )[ 0 ],\n\n\tenvironment: 'ENVMAP',\n\tenvMap: envMaps[ 'Royal Esplanade' ],\n\n\tgradientTop: '#bfd8ff',\n\tgradientBottom: '#ffffff',\n\n\tenvironmentIntensity: 3.0,\n\tenvironmentBlur: 0.35,\n\n\tbackgroundType: 'Gradient',\n\tbgGradientTop: '#111111',\n\tbgGradientBottom: '#000000',\n\n\tenable: true,\n\tbounces: 3,\n\n\tfloorColor: '#080808',\n\tfloorEnabled: true,\n\n};\n\nlet gui = null;\nfunction buildGui() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tgui = new GUI();\n\n\tgui.add( params, 'model', Object.keys( models ) ).onChange( updateModel );\n\n\tconst resolutionFolder = gui.addFolder( 'resolution' );\n\tresolutionFolder.add( params, 'resolutionScale', 0.1, 1.0, 0.01 ).onChange( v => {\n\n\t\tviewer.setScale( parseFloat( v ) );\n\n\t} );\n\tresolutionFolder.add( params, 'samplesPerFrame', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.samplesPerFrame = parseInt( v );\n\n\t} );\n\tresolutionFolder.add( params, 'tilesX', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.tiles.x = parseInt( v );\n\n\t} );\n\tresolutionFolder.add( params, 'tilesY', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.tiles.y = parseInt( v );\n\n\t} );\n\tresolutionFolder.open();\n\n\tconst environmentFolder = gui.addFolder( 'environment' );\n\tenvironmentFolder.add( params, 'envMap', envMaps ).name( 'map' ).onChange( updateEnvMap );\n\tenvironmentFolder.add( params, 'environmentBlur', 0.0, 1.0, 0.01 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.environmentBlur = parseFloat( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} ).name( 'env map blur' );\n\tenvironmentFolder.add( params, 'environmentIntensity', 0.0, 10.0, 0.01 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.environmentIntensity = parseFloat( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} ).name( 'intensity' );\n\tenvironmentFolder.open();\n\n\tconst backgroundFolder = gui.addFolder( 'background' );\n\tbackgroundFolder.add( params, 'backgroundType', [ 'Environment', 'Gradient' ] ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'GRADIENT_BG', Number( v === 'Gradient' ) );\n\t\tif ( v === 'Gradient' ) {\n\n\t\t\tviewer.scene.background = new Color( 0x060606 );\n\n\t\t} else {\n\n\t\t\tviewer.scene.background = viewer.scene.environment;\n\n\t\t}\n\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.addColor( params, 'bgGradientTop' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.bgGradientTop.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.addColor( params, 'bgGradientBottom' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.bgGradientBottom.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.open();\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.add( params, 'floorEnabled' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'DISPLAY_FLOOR', Number( v ) );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tfloorFolder.addColor( params, 'floorColor' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.floorColor.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\n\tconst pathTracingFolder = gui.addFolder( 'path tracing' );\n\tpathTracingFolder.add( params, 'enable' ).onChange( v => {\n\n\t\tviewer.enablePathTracing = v;\n\n\t} );\n\tpathTracingFolder.add( params, 'acesToneMapping' ).onChange( v => {\n\n\t\tviewer.renderer.toneMapping = v ? ACESFilmicToneMapping : NoToneMapping;\n\t\tviewer.fsQuad.material.needsUpdate = true;\n\n\t} );\n\tpathTracingFolder.add( params, 'bounces', 1, 20, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'BOUNCES', parseInt( v ) );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tpathTracingFolder.open();\n\n}\n\nfunction updateEnvMap() {\n\n\tnew RGBELoader()\n\t\t.load( params.envMap, texture => {\n\n\t\t\tif ( viewer.ptRenderer.material.environmentMap ) {\n\n\t\t\t\tviewer.ptRenderer.material.environmentMap.dispose();\n\t\t\t\tviewer.scene.environment.dispose();\n\n\t\t\t}\n\n\t\t\tconst pmremGenerator = new PMREMGenerator( viewer.renderer );\n\t\t\tpmremGenerator.compileCubemapShader();\n\n\t\t\tconst envMap = pmremGenerator.fromEquirectangular( texture );\n\n\t\t\ttexture.mapping = EquirectangularReflectionMapping;\n\t\t\tviewer.ptRenderer.material.environmentIntensity = parseFloat( params.environmentIntensity );\n\t\t\tviewer.ptRenderer.material.environmentMap = envMap.texture;\n\t\t\tviewer.scene.environment = texture;\n\t\t\tif ( params.backgroundType !== 'Gradient' ) {\n\n\t\t\t\tviewer.scene.background = texture;\n\n\t\t\t}\n\n\t\t\tviewer.ptRenderer.reset();\n\n\t\t} );\n\n}\n\nasync function updateModel() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\t\tgui = null;\n\n\t}\n\n\tlet model;\n\tconst manager = new LoadingManager();\n\tconst modelInfo = models[ params.model ];\n\n\tviewer.pausePathTracing = true;\n\tviewer.renderer.domElement.style.visibility = 'hidden';\n\tsamplesEl.innerText = '--';\n\tcreditEl.innerText = '--';\n\tloadingEl.innerText = 'Loading';\n\tloadingEl.style.visibility = 'visible';\n\n\tconst onFinish = async () => {\n\n\t\tif ( modelInfo.rotation ) {\n\n\t\t\tmodel.rotation.set( ...modelInfo.rotation );\n\n\t\t}\n\n\t\tif ( modelInfo.removeEmission ) {\n\n\t\t\tmodel.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tc.material.emissiveMap = null;\n\t\t\t\t\tc.material.emissiveIntensity = 0;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tc.material.side = DoubleSide;\n\n\t\t\t\tif ( c.material.opacity < 1 ) {\n\n\t\t\t\t\t// small hack to account for double sidedness making geometry look more opaque than intended\n\t\t\t\t\tc.material.opacity *= 0.75;\n\n\t\t\t\t}\n\n\t\t\t\t// boost particularly dark colors because all detail is lost with\n\t\t\t\t// dark lambert shading\n\t\t\t\tconst hsl = {};\n\t\t\t\tc.material.color.getHSL( hsl );\n\t\t\t\tif ( hsl.l < 0.025 ) {\n\n\t\t\t\t\thsl.l = 0.025;\n\t\t\t\t\tc.material.color.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// center the model\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( model );\n\t\tmodel.position\n\t\t\t.addScaledVector( box.min, - 0.5 )\n\t\t\t.addScaledVector( box.max, - 0.5 );\n\n\t\tconst sphere = new Sphere();\n\t\tbox.getBoundingSphere( sphere );\n\n\t\tmodel.scale.setScalar( 1 / sphere.radius );\n\t\tmodel.position.multiplyScalar( 1 / sphere.radius );\n\n\t\tawait viewer.setModel( model, { onProgress: v => {\n\n\t\t\tconst percent = Math.floor( 100 * v );\n\t\t\tloadingEl.innerText = `Building BVH : ${ percent }%`;\n\n\t\t} } );\n\n\t\tloadingEl.style.visibility = 'hidden';\n\n\t\tcreditEl.innerHTML = modelInfo.credit || '';\n\t\tcreditEl.style.visibility = modelInfo.credit ? 'visible' : 'hidden';\n\t\tbuildGui();\n\n\t\tviewer.pausePathTracing = false;\n\t\tviewer.renderer.domElement.style.visibility = 'visible';\n\t\tviewer.ptRenderer.material.uniforms.floorHeight.value = - ( box.max.y - box.min.y ) / ( 2 * sphere.radius );\n\n\t};\n\n\tconst url = modelInfo.url;\n\tif ( /(gltf|glb)$/i.test( url ) ) {\n\n\t\tmanager.onLoad = onFinish;\n\t\tnew GLTFLoader( manager )\n\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t.load(\n\t\t\t\turl,\n\t\t\t\tgltf => {\n\n\t\t\t\t\tmodel = gltf.scene;\n\n\t\t\t\t},\n\t\t\t\tprogress => {\n\n\t\t\t\t\tif ( progress.total !== 0 && progress.total >= progress.loaded ) {\n\n\t\t\t\t\t\tconst percent = Math.floor( 100 * progress.loaded / progress.total );\n\t\t\t\t\t\tloadingEl.innerText = `Loading : ${ percent }%`;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t);\n\n\t} else if ( /mpd$/i.test( url ) ) {\n\n\t\tmanager.onProgress = ( url, loaded, total ) => {\n\n\t\t\tconst percent = Math.floor( 100 * loaded / total );\n\t\t\tloadingEl.innerText = `Loading : ${ percent }%`;\n\n\t\t};\n\n\t\tconst loader = new LDrawLoader( manager );\n\t\tawait loader.preloadMaterials( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr' );\n\t\tloader\n\t\t\t.setPartsLibraryPath( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/' )\n\t\t\t.load(\n\t\t\t\turl,\n\t\t\t\tresult => {\n\n\t\t\t\t\tmodel = LDrawUtils.mergeObject( result );\n\t\t\t\t\tmodel.rotation.set( Math.PI, 0, 0 );\n\t\t\t\t\tmodel.traverse( c => {\n\n\t\t\t\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\t\t\t\tc.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tonFinish();\n\n\t\t\t\t},\n\t\t\t);\n\n\n\t}\n\n\n}\n\nconst stats = new Stats();\ndocument.body.appendChild( stats.dom );\nviewer.renderer.physicallyCorrectLights = true;\nviewer.renderer.toneMapping = ACESFilmicToneMapping;\nviewer.ptRenderer.material.setDefine( 'GRADIENT_BG', 1 );\nviewer.scene.background = new Color( 0x060606 );\nviewer.ptRenderer.tiles.set( params.tilesX, params.tilesY );\nviewer.setScale( params.resolutionScale );\nviewer.onRender = () => {\n\n\tstats.update();\n\tconst samples = Math.floor( viewer.ptRenderer.samples );\n\tsamplesEl.innerText = `samples: ${ samples }`;\n\n};\n\nupdateModel();\nupdateEnvMap();\n","import { Scene, WebGLRenderer, MeshBasicMaterial, Vector2, Mesh, PerspectiveCamera, sRGBEncoding } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { SAH } from 'three-mesh-bvh';\nimport { GenerateMeshBVHWorker } from 'three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js';\nimport { PathTracingRenderer } from '../core/PathTracingRenderer.js';\nimport { mergeMeshes } from '../utils/GeometryPreparationUtils.js';\nimport { LambertPathTracingMaterial } from '../materials/LambertPathTracingMaterial.js';\nimport { MaterialReducer } from '../core/MaterialReducer.js';\n\nexport class PathTracingViewer {\n\n\tget domElement() {\n\n\t\treturn this._container;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.scene = new Scene();\n\t\tthis.camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.025, 500 );\n\t\tthis.camera.position.set( 1, 0.5, 1 );\n\n\t\tthis.renderer = new WebGLRenderer( { antialias: true } );\n\t\tthis.fsQuad = new FullScreenQuad( new MeshBasicMaterial( { transparent: true } ) );\n\t\tthis.ptRenderer = new PathTracingRenderer( this.renderer );\n\t\tthis.ptModel = null;\n\t\tthis.ptMaterials = null;\n\t\tthis.ptTextures = null;\n\t\tthis.model = null;\n\t\tthis.bvhGenerator = new GenerateMeshBVHWorker();\n\t\tthis.onRender = null;\n\t\tthis.enablePathTracing = true;\n\t\tthis.pausePathTracing = false;\n\t\tthis.samplesPerFrame = 1;\n\t\tthis._scale = 1;\n\t\tthis._nextObject = null;\n\t\tthis._needsSizeUpdate = false;\n\t\tthis._newSize = new Vector2();\n\t\tthis._resizeObserver = new ResizeObserver( entries => {\n\n\t\t\tconst { contentRect } = entries[ 0 ];\n\t\t\tthis._newSize.set( contentRect.width, contentRect.height );\n\t\t\tthis._needsSizeUpdate = true;\n\n\t\t} );\n\n\t\tconst container = document.createElement( 'div' );\n\t\tcontainer.style.overflow = 'hidden';\n\t\tcontainer.appendChild( this.renderer.domElement );\n\t\tthis._container = container;\n\n\t\tthis.ptRenderer.camera = this.camera;\n\t\tthis.ptRenderer.material = new LambertPathTracingMaterial( { transparent: true, depthWrite: false } );\n\t\tthis.renderer.outputEncoding = sRGBEncoding;\n\t\tthis._resizeObserver.observe( container );\n\n\t}\n\n\t_updateSize() {\n\n\t\tconst dpr = window.devicePixelRatio;\n\t\tconst scale = this._scale;\n\t\tconst size = this._newSize;\n\t\tthis.renderer.setPixelRatio( dpr );\n\n\t\tthis.renderer.domElement.style.aspectRatio = `${ size.width } / ${ size.height }`;\n\t\tthis.renderer.domElement.style.width = `100%`;\n\t\tthis.renderer.setSize( scale * size.width, scale * size.height, false );\n\t\tthis.ptRenderer.target.setSize( size.width * scale * dpr, size.height * scale * dpr );\n\t\tthis.camera.aspect = size.width / size.height;\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis._needsSizeUpdate = false;\n\n\t}\n\n\tsetScale( scale ) {\n\n\t\tthis._scale = scale;\n\t\tthis._needsSizeUpdate = true;\n\n\t}\n\n\tsetModel( object, bvhOptions = {} ) {\n\n\t\tif ( this.bvhGenerator.running ) {\n\n\t\t\tthis._nextObject = object;\n\t\t\treturn;\n\n\t\t}\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tconst materialReducer = new MaterialReducer();\n\t\tmaterialReducer.process( object );\n\n\t\tconst meshes = [];\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { geometry, materials, textures } = mergeMeshes( meshes, { attributes: [ 'position', 'normal', 'tangent', 'uv' ] } );\n\t\treturn this\n\t\t\t.bvhGenerator\n\t\t\t.generate( geometry, { strategy: SAH, maxLeafTris: 1, ...bvhOptions } )\n\t\t\t.then( bvh => {\n\n\t\t\t\tif ( this._nextObject ) {\n\n\t\t\t\t\tthis.setModel( this._nextObject );\n\t\t\t\t\tthis._nextObject = null;\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.model ) {\n\n\t\t\t\t\tthis.scene.remove( this.model );\n\t\t\t\t\tthis.ptTextures.forEach( tex => tex.dispose() );\n\t\t\t\t\tthis.ptMaterials.forEach( mat => mat.dispose() );\n\n\t\t\t\t}\n\n\t\t\t\tconst mesh = new Mesh( geometry );\n\t\t\t\tthis.scene.add( object );\n\t\t\t\tthis.ptModel = mesh;\n\t\t\t\tthis.ptMaterials = materials;\n\t\t\t\tthis.ptTextures = textures;\n\t\t\t\tthis.model = object;\n\n\t\t\t\tconst { ptRenderer } = this;\n\t\t\t\tconst { material } = ptRenderer;\n\n\t\t\t\t// dispose of textures because they cannot be updated in later version of three.js\n\t\t\t\tmaterial.bvh.dispose();\n\t\t\t\tmaterial.normalAttribute.dispose();\n\t\t\t\tmaterial.tangentAttribute.dispose();\n\t\t\t\tmaterial.uvAttribute.dispose();\n\t\t\t\tmaterial.materialIndexAttribute.dispose();\n\t\t\t\tmaterial.textures.dispose();\n\n\t\t\t\tmaterial.bvh.updateFrom( bvh );\n\t\t\t\tmaterial.normalAttribute.updateFrom( geometry.attributes.normal );\n\t\t\t\tmaterial.tangentAttribute.updateFrom( geometry.attributes.tangent );\n\t\t\t\tmaterial.uvAttribute.updateFrom( geometry.attributes.uv );\n\t\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\n\t\t\t\tmaterial.textures.setTextures( this.renderer, 2048, 2048, textures );\n\t\t\t\tmaterial.materials.updateFrom( materials, textures );\n\t\t\t\tmaterial.setDefine( 'MATERIAL_LENGTH', materials.length );\n\t\t\t\tptRenderer.reset();\n\n\t\t\t} );\n\n\t}\n\n\tsetEnvironment( envMap ) {\n\n\t\tthis.scene.environment = envMap;\n\n\t}\n\n\tinit() {\n\n\t\tconst { ptRenderer, renderer, fsQuad, camera } = this;\n\n\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\tlet delaySamples = 0;\n\t\tcontrols.addEventListener( 'change', () => {\n\n\t\t\tconst tiles = this.ptRenderer.tiles;\n\t\t\tif ( tiles.x * tiles.y !== 1 ) {\n\n\t\t\t\tdelaySamples = 1;\n\n\t\t\t}\n\n\t\t\tptRenderer.reset();\n\n\t\t} );\n\n\t\trenderer.setAnimationLoop( () => {\n\n\t\t\tif ( this.pausePathTracing ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this._needsSizeUpdate ) {\n\n\t\t\t\tthis._updateSize();\n\t\t\t\tthis.ptRenderer.reset();\n\n\t\t\t}\n\n\t\t\tif ( this.model ) {\n\n\t\t\t\tif ( this.enablePathTracing && delaySamples === 0 ) {\n\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t\tfor ( let i = 0, l = this.samplesPerFrame; i < l; i ++ ) {\n\n\t\t\t\t\t\tptRenderer.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ptRenderer.samples < 1 ) {\n\n\t\t\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.autoClear = false;\n\t\t\t\t\tfsQuad.material.map = ptRenderer.target.texture;\n\t\t\t\t\tfsQuad.render( renderer );\n\t\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( delaySamples > 0 ) {\n\n\t\t\t\t\t\tdelaySamples --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tif ( this.onRender ) {\n\n\t\t\t\tthis.onRender();\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeBufferGeometries } from './BufferGeometryUtils.js';\n\nclass LDrawUtils {\n\n\tstatic mergeObject( object ) {\n\n\t\t// Merges geometries in object by materials and returns new object. Use on not indexed geometries.\n\t\t// The object buffers reference the old object ones.\n\t\t// Special treatment is done to the conditional lines generated by LDrawLoader.\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const i in meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const i in linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const i in condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"names":["$175d78eba0411401$var$_tempVec0","$hGT0Q","Vector3","$175d78eba0411401$var$_tempVec1","$175d78eba0411401$var$LDrawConditionalLineMaterial","ShaderMaterial","parameters","super","uniforms","UniformsUtils","merge","UniformsLib","fog","diffuse","value","Color","opacity","vertexShader","fragmentShader","Object","defineProperties","this","get","set","color","setValues","isLDrawConditionalLineMaterial","$175d78eba0411401$var$ConditionalLineSegments","LineSegments","geometry","material","isConditionalLine","$175d78eba0411401$var$_ray","Ray","$175d78eba0411401$var$isPartType","type","$175d78eba0411401$var$LineParser","line","lineNumber","lineLength","length","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","$175d78eba0411401$var$LDrawParsedCache","loader","_cache","cloneResult","original","result","faces","map","face","colorCode","vertices","v","clone","normals","faceNormal","conditionalSegments","controlPoints","lineSegments","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","FileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","Error","parse","text","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v0","v1","v2","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","push","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","fileMap","inverted","getData","key","Promise","fetchData","then","info","$175d78eba0411401$var$getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","$175d78eba0411401$var$LDrawPartsGeometryCache","parseCache","info1","faceMaterials","Set","processInfoSubobjects","async","subobject","promises","i","l","promise","ensureDataLoaded","subobjectInfo","test","loadModel","catch","error","Group","subobjectInfos","all","i3","l3","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","add","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","ls","applyMatrix4","i5","l5","os","i6","l6","tri","reverse","i4","l4","smoothNormals","checkSubSegments","size","subVectors","crossVectors","normalize","$175d78eba0411401$var$generateFaceNormals","hashMultiplier","hashVertex","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","hardEdgeRays","Map","halfEdgeList","rh1","has","rh2","distances","d0","d1","i1","l1","vertCount","i2","index","next","hash","rayHash","found","halfEdge","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","l2","$175d78eba0411401$var$smoothNormals","group1","$175d78eba0411401$var$createObject","hasCachedModel","getCachedModel","processIntoMesh","$175d78eba0411401$var$sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","$175d78eba0411401$export$12d9a9ad6192c950","Loader","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","url","colorLineRegex","directive","load","onLoad","onProgress","onError","parseModel","computeConstructionSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","c","isLineSegments","traverse","isMesh","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mainMat","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","parseInt","isNaN","max","min","MeshStandardMaterial","roughness","metalness","transparent","premultipliedAlpha","depthWrite","convertSRGBToLinear","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","LineBasicMaterial","model","stepNumber","constructionStep","numConstructionSteps","$669e55165c7dd739$export$7516d43a05de11c0","defines","BOUNCES","MATERIAL_LENGTH","USE_ENVMAP","GRADIENT_BG","DISPLAY_FLOOR","bvh","$mNwkg","MeshBVHUniformStruct","normalAttribute","FloatVertexAttributeTexture","tangentAttribute","uvAttribute","materialIndexAttribute","UIntVertexAttributeTexture","$1yYrt","MaterialStructArrayUniform","textures","$bOW4I","RenderTarget2DArray","texture","cameraWorldMatrix","invProjectionMatrix","environmentBlur","environmentIntensity","environmentMap","seed","gradientTop","gradientBottom","bgGradientTop","bgGradientBottom","floorHeight","floorColor","shaderStructs","shaderIntersectFunction","$6TM0u","shaderMaterialStructs","pathTracingHelpers","defineProperty","setDefine","needsUpdate","$8f71e3f3db300a4e$var$isTypedArray","arr","buffer","ArrayBuffer","$8f71e3f3db300a4e$export$c80603c061964928","ignoreKeys","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","constructor","clear","hasOwnProperty","Function","key1","keys","from","values","delete","process","object","replaced","processMaterial","foundMaterial","otherMaterial","isTexture","image","foundTexture","retained","$02840fc4832269db$var$Stats","mode","container","document","createElement","addPanel","panel","appendChild","dom","showPanel","id","style","display","cssText","addEventListener","event","preventDefault","beginTime","performance","Date","now","prevTime","frames","fpsPanel","Panel","msPanel","self","memory","memPanel","REVISION","begin","end","time","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","fg","bg","round","PR","window","devicePixelRatio","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","canvas","width","height","context","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","maxValue","drawImage","$02840fc4832269db$export$2e2bcd8739ae039","$012fa335e9becd54$var$creditEl","getElementById","$012fa335e9becd54$var$loadingEl","$012fa335e9becd54$var$samplesEl","$012fa335e9becd54$var$viewer","_container","scene","Scene","camera","PerspectiveCamera","innerWidth","innerHeight","renderer","WebGLRenderer","antialias","fsQuad","$hwk6U","FullScreenQuad","MeshBasicMaterial","ptRenderer","$eSUte","PathTracingRenderer","ptModel","ptMaterials","ptTextures","bvhGenerator","$hqWxi","GenerateMeshBVHWorker","onRender","enablePathTracing","pausePathTracing","samplesPerFrame","_scale","_nextObject","_needsSizeUpdate","_newSize","Vector2","_resizeObserver","ResizeObserver","entries","contentRect","overflow","outputEncoding","sRGBEncoding","observe","_updateSize","dpr","setPixelRatio","aspectRatio","setSize","target","aspect","updateProjectionMatrix","setScale","setModel","bvhOptions","running","updateMatrixWorld","meshes","$bf8yd","mergeMeshes","attributes","generate","strategy","SAH","maxLeafTris","remove","tex","dispose","mat","mesh","updateFrom","normal","tangent","uv","materialIndex","setTextures","reset","setEnvironment","envMap","environment","init","controls","$W2bOH","OrbitControls","delaySamples","tiles","setAnimationLoop","samples","render","autoClear","body","$012fa335e9becd54$var$envMaps","Overpass","$012fa335e9becd54$var$models","MODEL_LIST","credit","rotation","PI","removeEmission","Statue","$012fa335e9becd54$var$params","acesToneMapping","resolutionScale","tilesX","tilesY","backgroundType","enable","bounces","floorEnabled","$012fa335e9becd54$var$gui","$012fa335e9becd54$var$updateEnvMap","$hYZ9M","RGBELoader","pmremGenerator","PMREMGenerator","compileCubemapShader","fromEquirectangular","mapping","EquirectangularReflectionMapping","background","$012fa335e9becd54$var$updateModel","destroy","LoadingManager","modelInfo","visibility","innerText","onFinish","emissiveMap","emissiveIntensity","side","DoubleSide","hsl","getHSL","setHSL","h","s","box","Box3","setFromObject","sphere","Sphere","getBoundingSphere","setScalar","radius","percent","floor","innerHTML","$ghLil","GUI","onChange","resolutionFolder","addFolder","open","environmentFolder","backgroundFolder","Number","addColor","floorFolder","pathTracingFolder","toneMapping","ACESFilmicToneMapping","NoToneMapping","$012fa335e9becd54$var$buildGui","$4EHgc","GLTFLoader","setMeshoptDecoder","$c0AwW","MeshoptDecoder","gltf","progress","total","loaded","preloadMaterials","extractGroup","newGeometry","originalPositions","getAttribute","array","originalNormals","numVertsGroup","count","start","vertStart","vertEnd","subarray","addGeometry","geometries","geoms","uuid","permuteAttribute","attribute","elemSize","verts","numVerts","meshGeometries","linesGeometries","condLinesGeometries","normalMatrix","Matrix3","matrixWorld","control0","control1","getNormalMatrix","applyNormalMatrix","groupIndex","groups","mergedObject","meshMaterialsIds","meshGeometry","mergedGeometry","$7N5zk","mergeBufferGeometries","linesMaterialsIds","lineGeometry","condLinesMaterialsIds","condLineGeometry","condLines","mergeObject","visible","$012fa335e9becd54$var$stats","physicallyCorrectLights"],"version":3,"file":"lambert.4cdbbda1.js.map"}