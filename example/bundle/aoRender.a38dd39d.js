var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},e={},n={},a=t.parcelRequire5b70;null==a&&((a=function(t){if(t in e)return e[t].exports;if(t in n){var a=n[t];delete n[t];var i={id:t,exports:{}};return e[t]=i,a.call(i.exports,i,i.exports),i.exports}var r=new Error("Cannot find module '"+t+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(t,e){n[t]=e},t.parcelRequire5b70=a);var i=a("hGT0Q"),r=a("hwk6U"),o=a("4EHgc"),l=a("W2bOH"),s=a("aBPXg"),d=a("c0AwW"),c=a("ghLil"),m=(i=a("hGT0Q"),a("mNwkg")),u=a("6TM0u");class f extends i.ShaderMaterial{get normalMap(){return this.uniforms.normalMap.value}set normalMap(t){this.uniforms.normalMap.value=t,this.setDefine("USE_NORMALMAP",t?null:"")}get normalMapType(){return i.TangentSpaceNormalMap}set normalMapType(t){if(t!==i.TangentSpaceNormalMap)throw new Error("AmbientOcclusionMaterial: Only tangent space normal map are supported")}constructor(t){super({defines:{SAMPLES:10},uniforms:{bvh:{value:new m.MeshBVHUniformStruct},radius:{value:1},seed:{value:0},normalMap:{value:null},normalScale:{value:new i.Vector2(1,1)}},vertexShader:"\n\n\t\t\t\tvarying vec3 vNorm;\n\t\t\t\tvarying vec3 vPos;\n\n\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\tvarying vec4 vTan;\n\n\t\t\t\t#endif\n\n                void main() {\n\n                    vec4 mvPosition = vec4( position, 1.0 );\n                    mvPosition = modelViewMatrix * mvPosition;\n                    gl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tmat3 modelNormalMatrix = transpose( inverse( mat3( modelMatrix ) ) );\n\t\t\t\t\tvNorm = normalize( modelNormalMatrix * normal );\n\t\t\t\t\tvPos = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\n\t\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\tvTan = tangent;\n\n\t\t\t\t\t#endif\n\n                }\n\n            ",fragmentShader:`\n                #define RAY_OFFSET 1e-5\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n                precision highp isampler2D;\n                precision highp usampler2D;\n                precision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n                #include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n                ${m.shaderStructs}\n                ${m.shaderIntersectFunction}\n\t\t\t\t${u.shaderMaterialStructs}\n\t\t\t\t${u.pathTracingHelpers}\n\n                uniform BVH bvh;\n                uniform int seed;\n\t\t\t\tuniform float radius;\n\n\t\t\t\tvarying vec3 vNorm;\n\t\t\t\tvarying vec3 vPos;\n\n\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\tuniform sampler2D normalMap;\n\t\t\t\t\tuniform vec2 normalScale;\n\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\tvarying vec4 vTan;\n\n\t\t\t\t#endif\n\n                void main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\t// compute the flat face surface normal\n\t\t\t\t\tvec3 fdx = vec3( dFdx( vPos.x ), dFdx( vPos.y ), dFdx( vPos.z ) );\n\t\t\t\t\tvec3 fdy = vec3( dFdy( vPos.x ), dFdy( vPos.y ), dFdy( vPos.z ) );\n\t\t\t\t\tvec3 faceNormal = normalize( cross( fdx, fdy ) );\n\n\t\t\t\t\t// find the max component to scale the offset to account for floating point error\n\t\t\t\t\tvec3 absPoint = abs( vPos );\n\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\tvec3 normal = vNorm;\n\n\t\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\tif ( length( vTan.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\tvec2 uv = vUv;\n\t\t\t\t\t\t\tvec3 tangent = normalize( vTan.xyz );\n\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * vTan.w );\n\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\tvec3 texNormal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\ttexNormal.xy *= normalScale;\n\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec3 rayOrigin = vPos + faceNormal * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\t\t\t\t\tfloat accumulated = 0.0;\n\t\t\t\t\tfor ( int i = 0; i < SAMPLES; i ++ ) {\n\n\t\t\t\t\t\t// sample the cosine weighted hemisphere and discard the sample if it's below\n\t\t\t\t\t\t// the geometric surface\n\t\t\t\t\t\tvec3 rayDirection = getHemisphereSample( normalize( normal ), rand4().xy );\n\n\t\t\t\t\t\t// check if we hit the mesh and its within the specified radius\n\t\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\t\tvec3 outNormal = vec3( 0.0 );\n\t\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\n\t\t\t\t\t\t// if the ray is above the geometry surface, and it doesn't hit another surface within the specified radius then\n\t\t\t\t\t\t// we consider it lit\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tdot( rayDirection, faceNormal ) > 0.0 &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, outNormal, barycoord, side, dist ) ||\n\t\t\t\t\t\t\t\tdist > radius\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\taccumulated += 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.rgb = vec3( accumulated / float( SAMPLES ) );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n                }\n\n            `});for(const t in this.uniforms)t in this||Object.defineProperty(this,t,{get(){return this.uniforms[t].value},set(e){this.uniforms[t].value=e}});this.setValues(t)}setDefine(t,e){null==e?t in this.defines&&(delete this.defines[t],this.needsUpdate=!0):this.defines[t]!==e&&(this.defines[t]=e,this.needsUpdate=!0)}}var p=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function a(n){for(var a=0;a<e.children.length;a++)e.children[a].style.display=a===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),a(++t%e.children.length)}),!1);var i=(performance||Date).now(),r=i,o=0,l=n(new p.Panel("FPS","#0ff","#002")),s=n(new p.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=n(new p.Panel("MB","#f08","#201"));return a(0),{REVISION:16,dom:e,addPanel:n,showPanel:a,begin:function(){i=(performance||Date).now()},end:function(){o++;var t=(performance||Date).now();if(s.update(t-i,200),t>=r+1e3&&(l.update(1e3*o/(t-r),100),r=t,o=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){i=this.end()},domElement:e,setMode:a}};p.Panel=function(t,e,n){var a=1/0,i=0,r=Math.round,o=r(window.devicePixelRatio||1),l=80*o,s=48*o,d=3*o,c=2*o,m=3*o,u=15*o,f=74*o,p=30*o,v=document.createElement("canvas");v.width=l,v.height=s,v.style.cssText="width:80px;height:48px";var h=v.getContext("2d");return h.font="bold "+9*o+"px Helvetica,Arial,sans-serif",h.textBaseline="top",h.fillStyle=n,h.fillRect(0,0,l,s),h.fillStyle=e,h.fillText(t,d,c),h.fillRect(m,u,f,p),h.fillStyle=n,h.globalAlpha=.9,h.fillRect(m,u,f,p),{dom:v,update:function(s,g){a=Math.min(a,s),i=Math.max(i,s),h.fillStyle=n,h.globalAlpha=1,h.fillRect(0,0,l,u),h.fillStyle=e,h.fillText(r(s)+" "+t+" ("+r(a)+"-"+r(i)+")",d,c),h.drawImage(v,m+o,u,f-o,p,m,u,f-o,p),h.fillRect(m+f-o,u,o,p),h.fillStyle=n,h.globalAlpha=.9,h.fillRect(m+f-o,u,o,r((1-s/g)*p))}}};var v=p;m=a("mNwkg");let h,g,w,y,M,x,S,P,b,T,E,N;const A={resolutionScale:1/window.devicePixelRatio,radius:2,samplesPerFrame:2,accumulate:!0,pause:!1};function F(){const t=window.innerWidth,e=window.innerHeight,n=window.devicePixelRatio*A.resolutionScale;S.setSize(t*n,e*n),P.setSize(t*n,e*n),h.setSize(t,e),h.setPixelRatio(window.devicePixelRatio),w.aspect=t/e,w.updateProjectionMatrix(),R()}function R(){E=0,N=0}function _(){if(requestAnimationFrame(_),M.update(),b.forEach((t=>{A.pause||t.seed++,t.radius=A.radius,t.setDefine("SAMPLES",A.samplesPerFrame)})),0===E||!A.pause){if(E++,N+=A.samplesPerFrame,A.accumulate&&!A.pause){const t=S.width,e=S.height;w.setViewOffset(t,e,Math.random()-.5,Math.random()-.5,t,e)}h.setRenderTarget(S),h.render(y,w),h.setRenderTarget(P),h.autoClear=!1,x.material.map=S.texture,x.material.opacity=A.accumulate?1/E:1,x.render(h),h.autoClear=!0}h.setRenderTarget(null),x.material.map=P.texture,x.material.opacity=1,x.render(h),T.innerText=`Samples: ${N}`}!async function(){h=new i.WebGLRenderer({antialias:!0}),h.outputEncoding=i.sRGBEncoding,document.body.appendChild(h.domElement),x=new r.FullScreenQuad(new i.MeshBasicMaterial({transparent:!0})),w=new i.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.025,500),w.position.set(-4,2,3),y=new i.Scene,g=new l.OrbitControls(w,h.domElement),g.addEventListener("change",(()=>{R()})),T=document.getElementById("samples"),S=new i.WebGLRenderTarget(1,1,{type:i.FloatType,encoding:i.LinearEncoding}),P=new i.WebGLRenderTarget(1,1,{type:i.FloatType,encoding:i.LinearEncoding}),b=[];const t=new s.PathTracingSceneGenerator,e=(new o.GLTFLoader).setMeshoptDecoder(d.MeshoptDecoder).loadAsync("https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/material-balls/material-ball.glb").then((e=>{const n=new i.Group,a=new i.Box3;a.setFromObject(e.scene);const r=new i.Sphere;a.getBoundingSphere(r),e.scene.scale.setScalar(2.5/r.radius),e.scene.updateMatrixWorld(),n.add(e.scene),a.setFromObject(e.scene);const o=new i.Mesh(new i.CylinderBufferGeometry(3,3,.05,200),new i.MeshStandardMaterial({color:1710618}));return o.geometry.clearGroups(),o.position.y=a.min.y-.025,n.add(o),t.generate(n)})).then((e=>{const{bvh:n}=e,a=new m.MeshBVHUniformStruct;a.updateFrom(n);const i=new Map,r=e.scene;r.traverse((t=>{if(t.isMesh){const e=t.material.normalMap;if(!i.has(e)){const n=new f({bvh:a,normalScale:t.material.normalScale,normalMap:e,normalMapType:t.material.normalMapType});i.set(e,n),b.push(n)}t.material=i.get(e)}})),y.add(r),t.dispose()}));await e,document.getElementById("loading").remove(),F(),window.addEventListener("resize",F);const n=new c.GUI;n.add(A,"resolutionScale",.1,1).onChange(F),n.add(A,"samplesPerFrame",1,10,1),n.add(A,"radius",0,4).onChange(R),n.add(A,"accumulate").onChange(R),n.add(A,"pause"),M=new v,document.body.appendChild(M.domElement),R(),_()}();
//# sourceMappingURL=aoRender.a38dd39d.js.map
